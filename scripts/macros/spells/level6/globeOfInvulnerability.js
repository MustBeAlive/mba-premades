import {mba} from "../../../helperFunctions.js";
import {queue} from "../../mechanics/queue.js";

async function item({ speaker, actor, token, character, item, args, scope, workflow }) {
    async function effectMacroDel() {
        new Sequence()

            .effect()
            .file("jb2a.shield.03.outro_explode.yellow")
            .attachTo(token)
            .size(8, { gridUnits: true })
            .opacity(0.6)
            .waitUntilFinished(-500)

            .thenDo(async () => {
                Sequencer.EffectManager.endEffects({ name: `${token.document.name} GlOInv` });
            })

            .play()
    };
    let effectData = {
        'name': workflow.item.name,
        'icon': workflow.item.img,
        'origin': workflow.item.uuid,
        'duration': {
            'seconds': 60
        },
        'flags': {
            'effectmacro': {
                'onDelete': {
                    'script': mba.functionToString(effectMacroDel)
                }
            },
            'mba-premades': {
                'spell': {
                    'globeOfInvulnerability': {
                        'castLevel': workflow.castData.castLevel
                    }
                }
            },
            'midi-qol': {
                'castData': {
                    baseLevel: 6,
                    castLevel: workflow.castData.castLevel,
                    itemUuid: workflow.item.uuid
                }
            }
        },
    };
    new Sequence()

        .wait(500)

        .effect()
        .file("jb2a.shield.03.intro.yellow")
        .attachTo(workflow.token)
        .size(8, { gridUnits: true })
        .opacity(0.6)
        .playbackRate(0.8)

        .effect()
        .file("jb2a.shield.03.loop.yellow")
        .attachTo(workflow.token)
        .size(8, { gridUnits: true })
        .delay(600)
        .fadeIn(500)
        .opacity(0.6)
        .playbackRate(0.8)
        .persist()
        .name(`${workflow.token.document.name} GlOInv`)

        .thenDo(async () => {
            await mba.createEffect(workflow.actor, effectData);
        })

        .play()
}

async function target(workflow) {
    let baseLevel = workflow.castData?.baseLevel ?? workflow.item.flags?.['mba-premades']?.spell?.castData?.baseLevel;
    if (!workflow.targets.size || baseLevel === undefined) return;
    let queueSetup = await queue.setup(workflow.item.uuid, 'globeOfInvulnerability', 90);
    if (!queueSetup) return;
    let distanceMap = {};
    let ignoreTargets = Array.from(workflow.targets).filter(i => {
        let nearbyAllies = mba.findNearby(i, 10, 'all', false, true);
        let invulnerableAllies = nearbyAllies.filter(j => mba.getEffects(j.actor).find(k => k.flags['mba-premades']?.spell?.globeOfInvulnerability));
        let validEffects = invulnerableAllies.filter(l => {
            let effect = mba.getEffects(l.actor).find(m => m.flags['mba-premades']?.spell?.globeOfInvulnerability);
            if (!effect) return;
            let level = effect.flags['mba-premades'].spell.globeOfInvulnerability.castLevel;
            let distance = distanceMap?.[l.id];
            if (!distance) {
                distance = mba.getDistance(workflow.token, l);
                distanceMap[l.id] = distance;
            }
            if (distance <= 10) return;
            if (level > baseLevel) return true;
        });
        if (validEffects.length) return true;
    });
    if (!ignoreTargets.length) {
        queue.remove(workflow.item.uuid);
        return;
    }
    let newTargets = Array.from(workflow.targets).filter(i => !ignoreTargets.includes(i));
    mba.updateTargets(newTargets.map(j => j.id));
    workflow.targets = new Set(newTargets);
    let targetNames = Array.from(ignoreTargets).map(t => t.document.name);
    ChatMessage.create({
        flavor: `Targets shielded by <u>Globe of Invulnerability</u>: ${targetNames}`,
        speaker: { 'alias': "MBA Premades" },
    });
    queue.remove(workflow.item.uuid);
}

export let globeOfInvulnerability = {
    'target': target,
    'item': item
};